### 为什么要给表加上主键

1. 保证数据的唯一性
2. 主键是表与表之间的关联
3. 加快数据库的操作速度

### 为什么加上索引后查找速度变快

没有加主键的表，数据无序的放置在磁盘存储器上，按行排列。加了主键的表，整个表会变成树状结构，即平衡树结构，整个表变成了 一个索引，也就是所谓的“聚集索引”。![303980-20170331183916477-93039637](E:\study\Note\Java\303980-20170331183916477-93039637.jpg)

其中树的所有节点（底部除外）的数据都是由主键字段中的数据构成，我们常指定id为主键

，最下面部分是真正的表中数据。假如我们执行以下sql语句：
select * from table where id = 1234;

首先根据索引定位到1234这个值所在的节点，然后再通过结点取到id=1234的数据行。

![303980-20170331183927805-434571358](E:\study\Note\Java\303980-20170331183927805-434571358.jpg)

![303980-20170331183940836-1426600354](E:\study\Note\Java\303980-20170331183940836-1426600354.png)

聚集索引中，查找速度以指数级别提升，用大O标记法就是O(log n)，n是记录总树，底数是树的分叉数，结果就是树的层次数。换言之，查找次数是以树的分叉数为底，记录总数的对数

### 为什么加索引后会使写入、修改、删除变慢？

因为平衡树这个结构必须一直维持在一个正确的状态， 增删改数据都会改变平衡树各节点中的索引数据内容，破坏树结构， 因此，在每次数据改变时， DBMS必须去重新梳理树（索引）的结构以确保它的正确，这会带来不小的性能开销，也就是为什么索引会给查询以外的操作带来副作用的原因



### 非聚集索引

非聚集索引和聚集索引一样， 同样是采用平衡树作为索引的数据结构。索引树结构中各节点的值来自于表中的索引字段。如果给表中多个字段加上索引 ， 那么就会出现多个独立的索引结构，每个索引（非聚集索引）互相之间不存在关联。每次给字段建一个新索引， 字段中的数据就会被复制一份出来， 用于生成索引。 因此， 给表添加索引，会增加表的体积， 占用磁盘存储空间

![303980-20170331184008805-68908020](E:\study\Note\Java\303980-20170331184008805-68908020.jpg)

非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据，如下图

![303980-20170331184024758-1937607304](E:\study\Note\Java\303980-20170331184024758-1937607304.jpg)

不管以任何方式查询表， 最终都会利用主键通过聚集索引来定位到数据， 聚集索引（主键）是通往真实数据所在的唯一路径



### 非聚集索引的二次查询问题

非聚集索引叶节点仍然是索引节点，只是有一个指针指向对应的数据块，此如果使用非聚集索引查询，而查询列中包含了其他该索引没有覆盖的列，那么他还要进行第二次的查询，查询节点上对应的数据行的数据。

解决方法：

#### 复合索引（覆盖索引）

建立两列以上的索引，即可查询复合索引里的列的数据而不需要进行回表二次查询，如index(col1, col2)，执行下面的语句

```sql
select col1, col2 from t1 where col1 = '213';
```

要注意使用复合索引需要满足最左侧索引的原则，也就是查询的时候如果where条件里面没有最左边的一到多列，索引就不会起作用。

#### innodb建立的索引，如果字段重复率很高索引，索引是什么样，查找效率如何

a、非聚簇索引存储了对主键的引用，如果select字段不在非聚簇索引内，就需要跳到主键索引（上图中从右边的索引树跳到左边的索引树），再获取select字段值

b、如果非聚簇索引值重复率高，那么查询时就会大量出现上图中从右边跳到左边的情况，导致整个流程很慢

c、如果where值重复率高的字段，select用了limit，只查较少数据，也就是跳的次数很少的情况下，还是可以建索引的（后来想想也没必要，limit限制了数量，全表扫描也很快，除非字段值是排序的，必须扫描完前面的所有值）

d、如果没有3这个前提，则不建议在值重复率高的字段上建索引，因为查询效率低，还需要维护索引![35158-20180628110430497-1856877204](E:\study\Note\Java\35158-20180628110430497-1856877204.png)

#### Mysql索引会失效的几种情况分析

1.如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)

　注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引

2.对于多列索引，不是使用的第一部分(第一个)，则不会使用索引

3.like查询是以%开头

4.如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引

5.如果mysql估计使用全表扫描要比使用索引快,则不使用索引

此外，查看索引的使用情况
show status like ‘Handler_read%';
大家可以注意：
handler_read_key:这个值越高越好，越高表示使用索引查询到的次数
handler_read_rnd_next:这个值越高，说明查询低效