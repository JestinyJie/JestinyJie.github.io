## 聚簇索引和非聚簇索引的区别

聚集索引

![img](https://images.cnblogs.com/cnblogs_com/ashou706/33.png)

非聚集索引

![img](https://images.cnblogs.com/cnblogs_com/ashou706/33.png)

聚集索引和非聚集索引的根本区别是数据记录的排列顺序和索引的排列顺序是否一致，聚集索引表记录的排列顺序与索引的排列顺序一致，优点是查询速度快，因为一旦具有第一个索引值的纪录被找到，具有连续索引值的记录也一定物理的紧跟其后，从而缩小了搜索范围，对于返回某一范围的数据效果最好。

聚集索引的缺点是对表进行修改速度较慢，这是为了保持表中的记录的物理顺序与索引的顺序一致，而把记录插入到数据页的相应位置，必须在数据页中进行数据重排，降低了执行速度。
　　非聚集索引指定了表中记录的逻辑顺序，数据记录的物理顺序和索引的顺序不一致，聚集索引和非聚集索引都采用了B树的结构，但非聚集索引的叶子层顺序并不与实际的数据页相同，而采用指向表中的记录在数据页中位置的方式。非聚集索引比聚集索引层次多，添加记录不会引起数据顺序的重组。在有大量不同数据的列上建立非聚集索引，可以提高数据的查询和修改速度。

在对聚集索引列查询时，聚集索引的速度要比非聚集索引速度快。

在对聚集索引列排序时，聚集索引的速度要比非聚集索引速度快。但是如果数据量比较大时，如10万以上，则二者的速度差别不明显。

###  聚集索引和非聚集的建立原则

在创建索引时要做到三个适当，即在适当的表上、适当的列上创建适当数量的索引。虽然这可以通过一句话来概括优化的索引的基本准则，但是要做到这一点的话，需要做出很大的努力。具体的来说，要做到这个三个适当有如下几个要求。

#### **5.1           根据表的大小来创建索引

虽然给表创建索引，可以提高查询的效率。但是需要注意的是，索引也需要一定的开销的。为此并不是说给所有的表都创建索引，那么就可以提高数据库的性能。这个认识是错误的。给所有的表都创建了索引，那么其反而会给数据库的性能造成负面的影响。因为此时滥用索引的开销可能已经远远大于由此带来的性能方面的收益。所以，数据库管理员首先需要做到，为合适的表来建立索引，而不是为所有的表建立索引。

一般来说，不需要为比较小的表创建索引。因为即使建立了索引，其性能也不会得到很大的改善。相反索引建立的开销，如维护成本等等，要比这个要大。也就是说，付出的要比得到的多，显然违反常理。

另外，就是对于超大的表，也不一定要建立索引。有些表虽然比较大，记录数量非常的多。但是此时为这个表建立索引并一定的合适。对于一些超大的表，建立索引有时候往往不能够达到预计的效果。而且在大表上建立索引，其索引的开销要比普通的表大的多。那么到底是否给大表建立索引呢？主要是看两个方面的内容。首先是需要关注一下，在这张大表中经常需要查询的记录数量。一般来说，如果经常需要查询的数据不超过10%到15%的话，那就没有必要为其建立索引的必要。因为此时建立索引的开销可能要比性能的改善大的多。如果数据库管理员需要得出一个比较精确的结论，那么就需要进行测试分析。

#### **5.2           ****根据列的特征来创建索引**

列的特点不同，索引创建的效果也不同。需要了解为哪些列创建索引可以起到事半功倍的效果。同时也需要了解为哪些列创建索引反而起到的是事倍功半的效果。

索引设置的是否恰当，不仅跟数据库设计架构有关，而且还跟企业的经济业务相关。虽然一开始已经做了索引的优化工作。但是随着后来经济数据的增加，这个索引的效果会越来越打折扣。所以需要隔一段时间，对数据库的索引进行优化。该去掉的去掉，该调整的调整，以提高数据库的性能。

 

#### **5.3           ****在一个表上创建多少索引合适**

通常来说，表的索引越多，其查询的速度也就越快。但是，表的更新速度则会降低。这主要是因为表的更新同时也是索引的更新。到底在表中创建多少索引合适，就需要在这个更新速度与查询速度之间取得一个均衡点。如对于一些数据仓库或者决策型数据库系统，其主要用来进行查询。相关的记录往往是在数据库初始化的时候导入。此时，设置的索引多一点，可以提高数据库的查询性能。同时因为记录不怎么更新，所以索引比较多的情况下，也不会影响到更新的速度。相反，如果那些表中经常需要更新记录，如一些事务型的应用系统，数据更新操作是家常便饭的事情。此时如果在一张表中建立过多的索引，则会影响到更新的速度。由于更新操作比较频繁，所以对其的负面影响，要比查询效率提升要大的多。此时就需要限制索引的数量，只在一些必要的字段上建立索引。

总之，在适当的表、适当的列上建立适当的索引。具体的索引优化内容还是需要在日常工作中继续体会与总结。

**下面的表总结了何时使用聚集索引或非聚集索引：**

| 动作描述      | 使用聚集索引 | 使用非聚集索引 |
| --------- | ------ | ------- |
| 列经常被分组排序  | 应      | 应       |
| 返回某范围内的数据 | 应      | 不应      |
| 一个或极少不同值  | 不应     | 不应      |
| 小数目的不同值   | 应      | 不应      |
| 大数目的不同值   | 不应     | 应       |
| 频繁更新的列    | 不应     | 应       |
| 外键列       | 应      | 应       |
| 主键列       | 应      | 应       |
| 频繁修改索引列   | 不应     | 应       |

## 锁的升级顺序



## concurrent包1.7和1.8的区别



## hashmap为什么用红黑树而不用平衡二叉树

**平衡二叉树**

平衡二叉树或者是一颗空的二叉排序树，或是具有下列性质的二叉排序树：

- 根节点的左子树和右子树的深度最多相差1
- 根节点的左子树和右子树都是平衡二叉树

**平衡因子**

平衡因子是该节点的左子树的深度与右子树的深度之差。

**最小不平衡子树**

在平衡二叉树的构造过程中，以距离插入节点最近的，且平衡因子的绝对值大于1 的节点为根的子树。

**红黑树**

红黑树是每个节点都带有颜色属性的二叉排序树，颜色或红色或黑色。除了具有二叉排序树的性质以外，还具有以下5个性质：
性质1. 节点是红色或黑色。
性质2. 根节点是黑色。
性质3 每个叶节点（NIL节点，空节点）是黑色的。
性质4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
性质5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

**红黑树和平衡二叉树的比较**

红黑树与平衡二叉树的查找性能相同。但是当插入节点和删除节点从而破坏树的平衡性时，红黑树需要做旋转调整的次数比平衡二叉树所需的旋转调整的次数要少的多，其查找，插入，删除的操作时间复杂度均为O(Log2n)。

