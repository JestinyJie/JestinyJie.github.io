### 浏览器从接收到一个URL到最后展示出页面，经历了哪些过程

域名解析 --> 发起TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求，浏览器得到html代码 --> 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --> 浏览器对页面进行渲染呈现给用户



### 死锁产生的原因和解决办法

**产生死锁的四个必要条件：**

1. 互斥条件：一个资源每次只能被一个进程使用
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
3. 不剥夺条件：进程已获得的资源，不能强行剥夺
4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待关系

**避免死锁：**

**(1).按同一顺序访问对象。**(注：避免出现循环)
**(2).避免事务中的用户交互。**(注：减少持有资源的时间，较少锁竞争)
**(3).保持事务简短并处于一个批处理中。**(注：同(2)，减少持有资源的时间)
**(4).使用较低的隔离级别。**(注：使用较低的隔离级别（例如已提交读）比使用较高的隔离级别（例如可序列化）持有共享锁的时间更短，减少锁竞争)



**解除死锁**

**剥夺资源：**从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；

**撤消进程：**可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等



###final finally 和 finalize的区别

final是修饰符

* 修饰类，不能再派生出新的子类，不能被继承
* 修饰方法，使用过程不能被修改，不能重载
* 修饰变量，只能读取不能修改，且在声明时必须给出初始值

finally是在异常处理时用来执行清除操作，无论异常是否发生，都会执行finally里面的代码，常用来关闭文件，io流等

finalize是一个方法，在垃圾回收器删除对象之前调用，用来整理系统资源或者执行其他清理工作

### 分布式环境下，怎么保证线程安全

**避免并发**

在分布式环境中，如果存在并发问题，那么很难通过技术去解决，或者解决的代价很大，所以我们首先要想想是不是可以通过某些策略和业务设计来避免并发。比如通过合理的时间调度，避开共享资源的存取冲突。另外，在并行任务设计上可以通过适当的策略，保证任务与任务之间不存在共享资源

**时间戳**

每次系统A发送变更给系统B的时候需要带上一个能标示时序的时间戳，系统B接到通知后会拿时间戳与存在的时间戳比较，只有当通知的时间戳大于存在的时间戳，才做更新

**串行化**

通过变分布式消息系统为单一系统就可以保证消息的有序性。当接收方没法处理调用有序性，可以通过一个队列先把调用信息缓存起来，然后再串行地处理这些调用

**数据库**

分布式环境中的共享资源**不能通过Java里同步方法或加锁**来保证线程安全，但数据库是分布式各服务器的共享点，可以通过数据库的高可靠一致性机制来满足需求。比如，可以通过唯一性索引来解决并发过程中重复数据的生产或重复任务的执行；另外有些更新计算操作也尽量通过sql来完成，因为在程序段计算好后再去更新就有可能发生脏复写问题，但通过一条sql来完成计算和更新就可以通过数据库的锁机制来保证update操作的一致性

**行锁**

有的事务比较复杂，无法通过一条sql解决问题，并且有存在并发问题，这时就需要通过行锁来解决。在表里添加一个标示锁的字段，每次操作前，先通过update这个锁字段来完成类似竞争锁的操作，操作完成后在update锁字段复位，标示已归还锁。这种方式比较安全，不好的地方在于这些update锁字段的操作就是额外的性能消耗

**统一触发途径**

当一个数据可能会被多个触发点或多个业务涉及到，就有并发问题产生的隐患，因此可以通过前期架构和业务设计，尽量统一触发途径，触发途径少了一是减少并发的可能，也有利于对于并发问题的分析和判断



###HashMap相关：

**默认长度16**

长度16或者其他2的幂,length - 1的值是所有二进制位全为1,这种情况下,index的结果等同于hashcode后几位的值只要输入的hashcode本身分布均匀,hash算法的结果就是均匀的

所以,HashMap的默认长度为16,是为了降低hash碰撞的几率



### String，StringBuilder，StringBuffer三者的区别

**运行速度：**

**StringBuilder > StringBuffer > String**

**String最慢的原因：**

String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。以下面一段代码为例：

 

```java
String str="abc";
System.out.println(str);
str=str+"de";
System.out.println(str);
```

 

　　如果运行这段代码会发现先输出“abc”，然后又输出“abcde”，好像是str这个对象被更改了，其实，这只是一种假象罢了，JVM对于这几行代码是这样处理的，首先创建一个String对象str，并把“abc”赋值给str，然后在第三行中，其实JVM又创建了一个新的对象也名为str，然后再把原来的str的值和“de”加起来再赋值给新的str，而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了，所以，str实际上并没有被更改，也就是前面说的String对象一旦创建之后就不可更改了。所以，Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。

　　而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。

　　另外，有时候我们会这样对字符串进行赋值

```java
String str="abc"+"de";
StringBuilder stringBuilder=new StringBuilder().append("abc").append("de");
System.out.println(str);
System.out.println(stringBuilder.toString());
```

　　这样输出结果也是“abcde”和“abcde”，但是String的速度却比StringBuilder的反应速度要快很多，这是因为第1行中的操作和

　　String str="abcde";

　　是完全一样的，所以会很快，而如果写成下面这种形式

```java
String str1="abc";
String str2="de";
String str=str1+str2;
```

　　那么JVM就会像上面说的那样，不断的创建、回收对象来进行这个操作了。速度就会很慢。

**线程安全：**

**在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的**

如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder

**总结：**

String：适用于少量的字符串操作的情况

StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况

StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况



### 抽象类和接口的区别

含有abstract修饰符的class即为抽象类，abstract类不能创建的实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。 

  接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。 

  下面比较一下两者的语法区别： 

1.    抽象类可以有构造方法，接口中不能有构造方法。    
2.    抽象类中可以有普通成员变量，接口中没有普通成员变量    
3.    抽象类中可以包含非抽象的普通方法，接口中的可以有非抽象方法，比如deaflut方法    
4.    抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然
    eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。    
5.    抽象类中可以包含静态方法，接口中不能包含静态方法    
6.    **抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。**    
7.    一个类可以实现多个接口，但只能继承一个抽象类。

###super()和this()能不能同时使用

不能同时使用，this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过



###nio与bio的了解以及说一下区别 

  BIO：同步阻塞式IO，服务器实现模式为**一个连接一个线程**，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。 

  NIO：同步非阻塞式IO，服务器实现模式为**一个请求一个线程**，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理

AIO ：在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了

**BIO、NIO、AIO适用场景分析:** 

​    BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。 

​    NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。 

​    AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。



| **编号** | **名词**  | **解释**                                   | **举例**                                   |
| ------ | ------- | ---------------------------------------- | ---------------------------------------- |
| **1**  | **同步**  | **指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪**     | **自己上街买衣服，自己亲自干这件事，别的事干不了。**             |
| **2**  | **异步**  | **异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知（异步的特点就是通知）** | **告诉朋友自己合适衣服的尺寸，大小，颜色，让朋友委托去卖，然后自己可以去干别的事。（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS）** |
| **3**  | **阻塞**  | **所谓阻塞方式的意思是指, 当试图对该文件描述符进行读写时, 如果当时没有东西可读,或者暂时不可写, 程序就进入等待 状态, 直到有东西可读或者可写为止** | **去公交站充值，发现这个时候，充值员不在（可能上厕所去了），然后我们就在这里等待，一直等到充值员回来为止。（当然现实社会，可不是这样，但是在计算机里确实如此。）** |
| **4**  | **非阻塞** | **非阻塞状态下, 如果没有东西可读, 或者不可写, 读写函数马上返回, 而不会等待，** | **银行里取款办业务时，领取一张小票，领取完后我们自己可以玩玩手机，或者与别人聊聊天，当轮我们时，银行的喇叭会通知，这时候我们就可以去了。** |

### 守护线程和用户线程

java中的线程分为两种：守护线程（Daemon）和用户线程（User）。

任何线程都可以设置为守护线程和用户线程，通过方法Thread.setDaemon(bool on)；true则把该线程设置为守护线程，反之则为用户线程。Thread.setDaemon()必须在Thread.start()之前调用，否则运行时会抛出异常。

两者的区别：

唯一的区别是判断虚拟机(JVM)何时离开，Daemon是为其他线程提供服务，如果全部的User Thread已经撤离，Daemon 没有可服务的线程，JVM撤离。也可以理解为守护线程是JVM自动创建的线程（但不一定），用户线程是程序创建的线程；比如JVM的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是Java虚拟机上仅剩的线程时，Java虚拟机会自动离开。



## Java对象头 

  HotSpot虚拟机中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。 

  对象头包括两部分：Mark Word 和 类型指针。 

- ​    Mark Word：Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，占用内存大小与虚拟机位长一致。   
- ​    类型指针：类型指针指向对象的类元数据，虚拟机通过这个指针确定该对象是哪个类的实例



## session/cookie 

  常用的会话跟踪技术是Cookie与Session。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。 

  联系： 

-    Cookie与Session都是用来跟踪浏览器用户身份的会话方式。   

  区别： 

-    Cookie数据存放在客户的**浏览器**上，Session数据放在**服务器**上。    
-    Cookie不是很安全，别人可以分析存放在本地的Cookie并进行Cookie欺骗,如果主要考虑到安全应当使用加密的Cookie或者Session。    
-    Session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用Cookie。    
-    单个Cookie在客户端的限制是4K，很多浏览器都限制一个站点最多保存20个Cookie



### 消息队列

个人认为消息队列的主要特点是异步处理，主要目的是减少请求响应时间和解耦。所以主要的使用场景就是将比较耗时而且不需要即时（同步）返回结果的操作作为消息放入消息队列。同时由于使用了消息队列，只要保证消息格式不变，消息的发送方和接收方并不需要彼此联系，也不需要受对方的影响，即解耦和。

使用场景的话，举个例子：

假设用户在你的软件中注册，服务端收到用户的注册请求后，它会做这些操作：

1. 校验用户名等信息，如果没问题会在数据库中添加一个用户记录
2. 如果是用邮箱注册会给你发送一封注册成功的邮件，手机注册则会发送一条短信
3. 分析用户的个人信息，以便将来向他推荐一些志同道合的人，或向那些人推荐他
4. 发送给用户一个包含操作指南的系统通知
5. 等等……

但是对于用户来说，注册功能实际只需要第一步，只要服务端将他的账户信息存到数据库中他便可以登录上去做他想做的事情了。至于其他的事情，非要在这一次请求中全部完成么？值得用户浪费时间等你处理这些对他来说无关紧要的事情么？所以实际当第一步做完后，服务端就可以把其他的操作放入对应的消息队列中然后马上返回用户结果，由消息队列异步的进行这些操作。

或者还有一种情况，同时有大量用户注册你的软件，再高并发情况下注册请求开始出现一些问题，例如邮件接口承受不住，或是分析信息时的大量计算使cpu满载，这将会出现虽然用户数据记录很快的添加到数据库中了，但是却卡在发邮件或分析信息时的情况，导致请求的响应时间大幅增长，甚至出现超时，这就有点不划算了。面对这种情况一般也是将这些操作放入消息队列（生产者消费者模型），消息队列慢慢的进行处理，同时可以很快的完成注册请求，不会影响用户使用其他功能。

所以在软件的正常功能开发中，并不需要去刻意的寻找消息队列的使用场景，而是当出现性能瓶颈时，去查看业务逻辑是否存在可以异步处理的耗时操作，如果存在的话便可以引入消息队列来解决。否则盲目的使用消息队列可能会增加维护和开发的成本却无法得到可观的性能提升，那就得不偿失了