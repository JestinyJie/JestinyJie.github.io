## jvm垃圾回收机制



![JVM架构图](E:\study\Note\Java\20170610165140237.png)

#### 2.运行时数据区（Runtime Data Area）

**方法区**（Method Area）

存放**类级别**的数据，包括**静态变量**。每个JVM只有一个方法区，它是一个共享的资源。

- OutOfMemoryError异常：当方法区无法满足内存的分配需求时

  #### 运行时常量池

  - 方法区的一部分
  - 用于存放编译期生成的各种字面量与符号引用
  - OutOfMemoryError异常：当常量池无法再申请到内存时

  #### 直接内存

  - NIO可以使用Native函数库直接分配堆外内存，堆中的DirectByteBuffer对象作为这块内存的引用进行操作
  - 大小不受Java堆大小的限制，受本机(服务器)内存限制
  - OutOfMemoryError异常：系统内存不足时

**堆区（Heap Area）**

所有的对象和它们相应的实例变量、数组都存储在这里。此区域的唯一目的就是存储对象实例。java堆是垃圾收集器管理的主要区域。java堆还可以细分为：**新生代与老年代**。在细一点有 Eden空间、Form Survivor空间、To Survivor空间等。每个JVM只有一个堆区。线程不安全

- 可以通过-Xmx和-Xms控制堆的大小
- OutOfMemoryError异常：当在堆中没有内存完成实例分配，且堆也无法再扩展时。

**栈区（Stack Area）**

每个线程运行会单独创建一个栈。局部变量在栈中创建。栈区是线程安全的。栈帧被分为三个子实体：

* 局部变量数组
* 操作数栈：在执行中间操作时，操作数栈作为运行时工作区去执行指令
* 帧数据：在任意异常的情况下，catch块的信息将会被保存在帧数据里面
* 线程私有，生命周期与线程相同
* java方法执行的内存模型，每个方法执行的同时都会创建一个栈帧，存储局部变量表(基本类型、对象引用)、操作数栈、动态链接、方法出口等信息
* StackOverflowError异常：当线程请求的栈深度大于虚拟机所允许的深度
* OutOfMemoryError异常：如果栈的扩展时无法申请到足够的内存

**PC寄存器**（程序计数器）

每个线程都有一个pc寄存器来存放当前指令的地址，不会出现OutOfMemoryError情况

**本地方法栈**

保存**本地方法**信息

​	当线程调用Java方法时，虚拟机会创建一个新的栈帧并压入Java栈。然而当它调用的是本地方法时，虚拟机会保持Java栈不变，不再在线程的Java栈中压入新的帧，虚拟机只是简单地动态连接并直接调用指定的本地方法



#### 3.执行引擎

分配给运行时数据区的字节码将由执行引擎执行，执行引擎读取字节码并逐段执行。

**解释器**

解释器用来解释字节码，但执行很慢。如果一个方法被调用多次，每次都需重新解释

**编译器**

JIT编译器消除了解释器的缺点，执行引擎利用解释器解释字节码，如果是重复的代码则用JIT编译器将全部字节码编译成本机代码。如果调用重复方法，直接调用本机代码即可，提高了系统性能。

* 中间代码生成器：生成中间代码
* 代码优化器：优化上述代码
* 目标代码生成器：生成机器代码或本机代码
* 探测器（Profiler）：寻找被多次调用的代码

**垃圾回收器（GC）**

收集并删除未引用的对象。可以通过调用*"System.gc()"*来触发垃圾回收，但并不保证会确实进行垃圾回收。JVM的垃圾回收只收集哪些由**new**关键字创建的对象。所以，如果不是用**new**创建的对象，你可以使用**finalize函数**来执行清理

![20180617161343935](E:\study\Note\Java\20180617161343935.png)

**![20171229170129423](E:\study\Note\Java\20171229170129423.png)**

程序创建的大部分对象的生命周期都很短，只有一小部分对象的生命周期比较长，根据这样的规律，一般把Java堆分为Young Generation（新生代），Old Generation（老年代）和Permanent Generation（持久代），上面几种算法是通过分代回收混合在一起的，这样就可以根据各个年代的特点采用最适当的回收算法。



（1）新生代

​    在新生代中，有一个叫Eden Space的空间，主要是用来存放新生的对象，还有两个Survivor Spaces（from、to）， 这两个区域大小相等，相当于copying算法中的两个区域，它们用来存放每次垃圾回收后存活下来的对象。在新生代中，垃圾回收一般用**Copying的算法**，速度快。

​    当新建对象无法放入eden区时，将触发minor collection（minorGC 是清理新生代的GC线程，eden的清理，from、to的清理都由MinorGC完成），将eden区与from区的存活对象复制到to区，经过一次垃圾回收，eden区和from区清空，to区中则紧密的存放着存活对象；当eden区再次满时，minor collection将eden区和to区的存活对象复制到from区，eden区和to区被清空，from区存放eden区和to区的存活对象，就这样from区和to区来回切换。如果进行minor collection的时候，**发现to区放不下，则将eden区和from区的部分对象放入成熟代**。另一方面，**即使to区没有满，JVM依然会移动世代足够久远的对象到成熟代**。

（2）成熟代

​    在成熟代中主要存放应用程序中生命周期长的内存对象，垃圾回收一般用**mark-compact的算法**，速度慢些，但减少内存要求。如果成熟代放满对象，无法从新生代移入新的对象，那么将触发major collection（major GC清理整合OldGen的内存空间）。

（3）永久代

   在永久代中，主要用来放JVM自己的反射对象，比如类对象、方法对象、成员变量对象、构造方法对象等。

​    此外，垃圾回收一般是在程序空闲的时候（没有工作线程，GC线程优先级较低）或者堆内存不足的时候自动触发，也可以调用System.gc()主动的通知Java虚拟机进行垃圾回收，但这只是个建议，Java虚拟机不一定马上执行，启动时机的选择由JVM决定，并且取决于堆内存中Eden区是否可用。



**虚拟机在进行MinorGC（新生代的GC）的时候，会判断要进入OldGeneration区域对象的大小，是否大于Old Generation剩余空间大小，如果大于就会发生Full GC**。

**刚分配对象在Eden中**，如果空间不足尝试进行GC，回收空间，如果进行了MinorGC空间依旧不够就放入Old Generation，如果OldGeneration空间还不够就OOM了。

​	**MinorGC：**指发生在新生代的GC，因大多数新生对象生命周期很短，所以MinorGC通常很频繁，回收速度也较快；

　　**MajorGC/FullGC：**指老年代GC，速度一般较慢，一般是MinorGC的10倍；通常MajorGC会伴随一次MinorGC；（书原话，有歧义）

 　  触发条件：

　　　　MinorGC：Eden区满时触发；FullGC也会伴随有MinorGC；通常会使得Old gen变大；

　　　　FullGC：a. MinorGC触发前，检查历次进入老年代的平均大小，若小于则FullGC；

　　　　　　　　b. 如果有永久代（perm gen），在不足哆分配时，触发FullGC；

　　　　　　　　c. 调用System.gc()，提醒JVM FullGC，但不可控；

比较大的对象，数组等，大于某值（可配置）就直接分配到老年代，（避免频繁内存拷贝）

**年轻代和年老代属于Heap空间的**

**Permanent Generation（永久代）可以理解成方法区，（它属于方法区）**也有可能发生GC，例如类的实例对象全部被GC了，同时它的类加载器也被GC掉了，这个时候就会触发永久代中对象的GC。

如果OldGeneration满了就会产生FullGC

满原因：1，from survive中对象的生命周期到一定阈值

2，分配的对象直接是大对象

3、由于To 空间不够，进行GC直接把对象拷贝到年老代（年老代GC时候采用不同的算法）

如果Young Generation大小分配不合理或空间比较小，这个时候导致对象很容易进入Old Generation中，而Old Generation中回收具体对象的时候速度是远远低于Young Generation回收速度。

因此实际分配要考虑年老代和新生代的比例，考虑Eden和survives的比例

Permanent Generation中发生GC的时候也对性能影响非常大，也是Full GC

> 1、一个人（对象）出来（new 出来）后会在Eden Space（伊甸园）无忧无虑的生活，直到GC到来打破了他们平静的生活。GC会逐一问清楚每个对象的情况，有没有钱（此对象的引用）啊，因为GC想赚钱呀，有钱的才可以敲诈嘛。然后富人就会进入Survivor Space（幸存者区），穷人的就直接kill掉。
>
> 2、并不是进入Survivor Space（幸存者区）后就保证人身是安全的，但至少可以活段时间。GC会定期（可以自定义）会对这些人进行敲诈，亿万富翁每次都给钱，GC很满意，就让其进入了Genured Gen(养老区)。万元户经不住几次敲诈就没钱了，GC看没有啥价值啦，就直接kill掉了。
>
> 3、进入到养老区的人基本就可以保证人身安全啦，但是亿万富豪有的也会挥霍成穷光蛋，只要钱没了，GC还是kill掉。

栈内存溢出：程序所要求的栈深度过大。 
堆内存溢出： 分清内存泄露还是 内存容量不足。泄露则看对象如何被 GC Root 引用，不足则通过调大-Xms，-Xmx参数。 
永久代溢出：Class对象未被释放，Class对象占用信息过多，有过多的Class对象。 
直接内存溢出：系统哪些地方会使用直接内存

 #### JVM GC时候核心参数：

**-XX：NewRatio –XX:SurvivorRatio –XX:NewSize –XX:MaxNewSize**

**–XX:NewSize–XX:MaxNewSize指定新生代初始大小和最大大小。**

1，-XX:NewRatio    是年老代 新生代相对的比例，比如NewRatio=2，表明年老代是新生代的2倍。老年代占了heap的2/3，新生代占了1/3

2，-XX:SurvivorRatio 配置的是在新生代里面Eden和一个Servive的比例

如果指定NewRatio还可以指定NewSizeMaxNewSize，如果同时指定了会如何？？？

NewRatio=2，这个时候新生代会尝试分配整个Heap大小的1/3的大小，但是分配的空间不会小于-XX:NewSize也不会大于 –XX:MaxNewSize

3，-XX:NewSize –XX:MaxNewSize

实际设置比例还是设置固定大小，固定大小理论上速度更高。

-XX:NewSize –XX:MaxNewSize理论越大越好，但是整个Heap大小是有限的，一般年轻代的设置大小不要超过年老代。

-XX:SurvivorRatio新生代里面Eden和一个Servive的比例，如果SurvivorRatio是5的话，也就是Eden区域是SurviveTo区域的5倍。Survive由From和To构成。结果就是整个Eden占用了新生代5/7，From和To分别占用了1/7,如果分配不合理，Eden太大，这样产生对象很顺利，但是进行GC有一部分对象幸存下来，拷贝到To，空间小，就没有足够的空间，对象会被放在old Generation中。如果Survive空间大，会有足够的空间容纳GC后存活的对象，但是Eden区域小，会被很快消耗完，这就增加了GC的次数



### 三种gc算法

#### 标记/清除算法

内存中的对象构成一棵树，当有效的内存被耗尽的时候，程序就会停止，做两件事，第一：标记，标记从树根可达的对象（途中水红色），第二：清除（清楚不可达的对象）。标记清除的时候有停止程序运行，如果不停止，此时如果存在新产生的对象，这个对象是树根可达的，但是没有被标记（标记已经完成了），会清除掉。

缺点：递归效率低性能低；释放空间不连续容易导致**内存碎片**；会停止整个程序运行；

![20170610165906970](E:\study\Note\Java\20170610165906970.png)

#### 复制算法

把内存分成两块区域：空闲区域和活动区域，第一还是标记（标记谁是可达的对象），标记之后把可达的对象复制到空闲区，将空闲区变成活动区，同时把以前活动区对象1，4清除掉，变成空闲区。

**速度快但耗费空间**，假定活动区域全部是活动对象，这个时候进行交换的时候就相当于多占用了一倍空间，但是没啥用![20170610165923256](E:\study\Note\Java\20170610165923256.png)

#### 标记/整理算法

标记过程和“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清除，而是让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存![20170610165941100](E:\study\Note\Java\20170610165941100.png)

**JVM垃圾回收分代收集算法**

综合了上述算法优略

1， 分代GC在新生代的算法：采用了GC的复制算法，速度快，因为新生代一般是新对象，都是瞬态的用了可能很快被释放的对象。

2， 分代GC在年老代的算法 标记／整理算法，GC后会执行压缩，整理到一个连续的空间，这样就维护着下一次分配对象的指针，下一次对象分配就可以采用碰撞指针技术，将新对象分配在第一个空闲的区域。



**7种垃圾收集器，前 3 个是新生代，后 3 个是老年代：**

并行收集和并发收集的区别：

（1）并行（Parallel）

​       **指多个垃圾收集线程并行工作，但此时用户线程仍然处于等待状态；**

​       如ParNew、Parallel Scavenge、Parallel Old；

（2）并发（Concurrent）

​       **指用户线程与垃圾收集线程同时执行**（但不一定是并行的，可能会交替执行）；用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；    

​       如CMS、G1（也有并行）；

![img](https://images2018.cnblogs.com/blog/1170065/201806/1170065-20180623154603452-99143360.png)

（1）  serial （复制算法）：单线程（单线程的意义不仅仅说明它会使用一个 cpu或一条垃圾收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集的时候，**必须暂停其他所有工作线程，直到他收集结束**）。

![img](https://images2018.cnblogs.com/blog/1170065/201806/1170065-20180623155338377-1047221565.png)

应用场景：

对于运行在 **client** 模式下的虚拟机来说是个很好的选择。

优点：

1）简单高效（与其他收集器的单线程相比）；

2）对于限定单个CPU的环境来说，Serial收集器没有线程交互（切换）开销，可以获得最高的单线程收集效率；

3）在用户的桌面应用场景中，可用内存一般不大（几十M至一两百M），可以在较短时间内完成垃圾收集（几十MS至一百多MS）,只要不频繁发生，这是可以接受的。

 

（2）  parNew （复制算法）：serial 收集器的多线程版本，是许多运行在 server 模式下的虚拟机首选的新生代收集器。

![img](https://images2018.cnblogs.com/blog/1170065/201806/1170065-20180623155610663-337696011.png)

 应用场景：

在**Server**模式下，ParNew收集器是一个非常重要的收集器，因为**除Serial外，目前只有它能与CMS收集器配合工作**；但在单个CPU环境中，不会比Serail收集器有更好的效果，因为存在线程交互开销。

 

（3）  parallel scaverge（复制算法）：其他与ParNew类似，特别之处在于：CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间；而其目标是达到一个可控制的吞吐量，适合在后台运算，没有太多的交互。

应用场景：

高吞吐量为目标，即减少垃圾收集时间，让用户代码获得更长的运行时间；当应用程序运行在具有多个CPU上，对暂停时间没有特别高的要求时，即程序主要在后台进行计算，而不需要与用户进行太多交互；例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。

 

（4）  serial old（标记-清理）：serial 的老年代版本，单线程，

![img](https://images2018.cnblogs.com/blog/1170065/201806/1170065-20180623160545143-1304419576.png)

应用场景：

主要用于Client模式；而在Server模式有两大用途：

（A）、在JDK1.5及之前，与Parallel Scavenge收集器搭配使用（JDK1.6有Parallel Old收集器可搭配）；

（B）、作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用（后面详解）；

 

（5）  parallel old（标记-清理）：parallel scaverge 老年代的版本，多线程 

![img](https://images2018.cnblogs.com/blog/1170065/201806/1170065-20180623160728170-1968009295.png)

应用场景：

JDK1.6及之后用来代替老年代的Serial Old收集器；特别是在Server模式，多CPU的情况下；这样在注重吞吐量以及CPU资源敏感的场景，就有了Parallel Scavenge加Parallel Old收集器的"给力"应用组合。

 

（6）  cms（Concurrent Mark-Sweep标记-清除） ：一种以获取最短回收停顿时间为目标的收集器 “标记-清除”，有 4 个过程：

**1）初始标记**（仅标记一下GC Roots能直接关联到的对象；速度很快；但需要"Stop The World"；）

**2）并发标记**（进行GC Roots Tracing的过程；刚才产生的集合中标记出存活对象；应用程序也在运行；并不能保证可以标记出所有的存活对象；）

**3）重新标记**（为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录；需要"Stop The World"，且停顿时间比初始标记稍长，但远比并发标记短；采用多线程并行执行来提升效率；）

**4）并发清除** （回收所有的垃圾对象）。

![img](https://images2018.cnblogs.com/blog/1170065/201806/1170065-20180623160902127-263647904.png)

**优点：并发收集，低停顿；**

**缺点：**

**1）不能处理浮动垃圾，**由于 cms 并发清除阶段，用户线程还在继续执行,伴随程序进行，还有新的垃圾产生，这一部分垃圾发生在标记之后，cms 无法在当次收集时处理他们，只能留到下一次gc。可能出现"Concurrent Mode Failure"失败。这时JVM启用后备预案：临时启用Serail Old收集器，而导致另一次Full GC的产生。

**2）对 cpu 资源敏感。**并发收集虽然不会暂停用户线程，但因为占用一部分CPU资源，还是会导致应用程序变慢，总吞吐量降低。**cms 默认启动的回收线程数是（cpu 数量+3）/4**。当CPU数量多于4个，收集线程占用的CPU资源多于25%，对用户程序影响可能较大；不足4个时，影响更大，可能无法接受。

**3）产生大量内存碎片 **，大对象分配困难，需要提前触发另一次Full GC动作。

　　

（7）G1：是一款面向服务端应用的商用垃圾收集器。具备四个特点：

1）**并行与并发**：能充分利用多CPU、多核环境下的硬件优势；可以使用多个CPU并行来缩短"Stop The World"停顿时间；也可以并发让垃圾收集与用户程序同时进行。

2）**分代收集**：能独立管理整个GC堆（新生代和老年代），而不需要与其他收集器搭配；能够采用不同方式处理不同时期的对象；虽然保留分代概念，但Java堆的内存布局有很大差别；将整个堆划分为多个大小相等的独立区域（Region）；新生代和老年代不再是物理隔离，它们都是一部分Region（不需要连续）的集合。

3）**空间整合**，不产生碎片：从整体看，是基于标记-整理算法；从局部（两个Region间）看，是基于复制算法；都不会产生内存碎片，有利于长时间运行，不会提前触发一次GC。

4）**可预测的停顿**：低停顿的同时实现高吞吐量；G1除了追求低停顿处，还能建立可预测的停顿时间模型；可以明确指定M毫秒时间片内，垃圾收集消耗的时间不超过N毫秒。