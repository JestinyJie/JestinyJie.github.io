匿名类（Anonymous Class）
　　当一个内部类的类声名只是在创建此类对象时用了一次，而且要产生的新类需继承于一个已有的父类或实现一个接口，才能考虑用匿名类，由于匿名类本身无名，因此它也就不存在构造方法，它需要显示地调用一个无参的父类的构造方法，并且重写父类的方法。

一般的用途：

1、覆盖某个超类的方法，并且该扩展类只在本类内用一次。

2、继承抽象类，并实例化其抽象方法，并且该扩展类只在本类内用一次。

3、实现接口，实例化其方法，并且该扩展类只在本类内用一次。

```java
f.addMouseMotionListener(new MouseMotionAdapter(){ //匿名类开始
　　　　　　　public void mouseDragged(MouseEvent e){
　　　　　　　　String s="Mouse dragging: x="+e.getX()+"Y="+e.getY();
　　　　　　　　tf.setText(s); }
　　　　　　} ); //匿名类结束
```

　　存在它的原因是:
　　1.一个内部类的对象能够访问创建它的对象的实现，包括私有数据。即内部类实例对包含它的哪个类的实例来说，是特权的。
　　2.对于同一个包中的其他类来说,内部类能够隐藏起来,换句话说，内部类不管方法的可见性如何，那怕是public，除了包容类，其他类都无法使用它。
　　3.匿名内部类可以很方便的定义回调。
　　4.使用内部类可以非常方便的编写事件驱动程序。
其实它真正的目的仅仅为了定义回调－－进一步就是事件驱动。

　在使用匿名内部类时，要记住以下几个原则： 
　　·匿名内部类不能有构造方法。   
　　·匿名内部类不能定义任何静态成员、方法和类。   
　　·匿名内部类不能是public,protected,private,static。   
　　·只能创建匿名内部类的一个实例。 
·一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。   
　　·因匿名内部类为局部内部类，所以局部内部类的所有限制都对其生效。  

匿名类和内部类中的中的this :
有时候，我们会用到一些内部类和匿名类。当在匿名类中用this时，这个this则指的是匿名类或内部类本身。 这时如果我们要使用外部类的方法和变量的话，则应该加上外部类的类名

 

**Part2:**

匿名内部类是没有名字的内部类,不能继承其它类,但一个内部类可以作为一个接口,由另一个内部类实现.
一、由于匿名内部类没有名字，所以它没有构造函数。因为没有构造函数，所以它必须完全借用父类的构造函数来实例化，换言之：匿名内部类完全把创建对象的任务交给了父类去完成。
二、在匿名内部类里创建新的方法没有太大意义，但它可以通过覆盖父类的方法达到神奇效果，如上例所示。这是多态性的体现。 
三、因为匿名内部类没有名字，所以无法进行向下的强制类型转换，持有对一个匿名内部类对象引用的变量类型一定是它的直接或间接父类类型。 
new <类或接口> <类的主体> 
匿名类 
匿名类是不能有名称的类，所以没办法引用它们。必须在创建时，作为new语句的一部分来声明它们。 
这就要采用另一种形式的new语句，如下所示： 
new <类或接口> <类的主体> 
这种形式的new语句声明一个新的匿名类，它对一个给定的类进行扩展，或者实现一个给定的接口。它还创建那个类的一个新实例，并把它作为语句的结果而返回。要扩展的类和要实现的接口是new语句的操作数，后跟匿名类的主体。
如果匿名类对另一个类进行扩展，它的主体可以访问类的成员、覆盖它的方法等等，这和其他任何标准的类都是一样的。如果匿名类实现了一个接口，它的主体必须实现接口的方法。 
注意匿名类的声明是在编译时进行的，实例化在运行时进行。这意味着for循环中的一个new语句会创建相同匿名类的几个实例，而不是创建几个不同匿名类的一个实例。
从技术上说，匿名类可被视为非静态的内部类，所以它们具有和方法内部声明的非静态内部类一样的权限和限制。 
如果要执行的任务需要一个对象，但却不值得创建全新的对象（原因可能是所需的类过于简单，或者是由于它只在一个方法内部使用），匿名类就显得非常有用。匿名类尤其适合在Swing应用程序中快速创建事件处理程序。
exp: 
return new Contents() { 
private int i = 11; 
public int value() { return i; } 
}; 
这种奇怪的语法要表达的意思是：“创建从Contents衍生出来的匿名类的一个对象”。由new表达式返回的句柄会自动上溯造型成一个Contents句柄。匿名内部类的语法其实要表达的是：
class MyContents extends Contents { 
private int i = 11; 
public int value() { return i; } 
} 
return new MyContents(); 
若试图定义内部类,并想使用在匿名内部类外部定义的一个对象,则编译器要求外部对象必须是final属性. 
public class Parcel9 { 
  public Destination 
  dest(final String dest, final float price) { 
​    return new Destination() { 
​      private int cost; 
​      // Instance initialization for each object: 
​      { 
​        cost = Math.round(price); 
​        if(cost > 100) 
​          System.out.println("Over budget!"); 
​      } 
​      private String label = dest; 
​      public String readLabel() { return label; } 
​    }; 
  } 
  public static void main(String[] args) { 
​    Parcel9 p = new Parcel9(); 
​    Destination d = p.dest("Tanzania", 101.395F); 
  } 
}