1. Java四种作用域？如果不写是什么？

   ![690292-20160923095944481-1758567758](E:\study\Note\Java\690292-20160923095944481-1758567758.png)

public：

具有最大的访问权限，可以访问任何一个在classpath下的类、接口、异常等。它往往用于对外的情况，也就是对象或类对外的一种接口的形式。

protected：

主要的作用就是用来保护子类的。它的含义在于子类可以用它修饰的成员，其他的不可以，它相当于传递给子类的一种继承的东西

default：

有时候也称为friendly，它是针对本包访问而设计的，任何处于本包下的类、接口、异常等，都可以相互访问，即使是父类没有用protected修饰的成员也可以。

private：

访问权限仅限于类的内部，是一种封装的体现，例如，大多数成员变量都是修饰符为private的，它们不希望被其他任何外部的类访问。

2. hashmap底层结构？key是否可以为null？null的hashcode是什么？新插入的数据在链表头还是尾？

   **HashMap的底层实现：Entry数组 + 链表 + 红黑树。**

   首先，在HashMap类中有一个Entry的内部类，这个Entry类包含了key-value作为实例变量。没当向HashMap中存放k-v对时，都会为其实例化一个Entry对象，则个Entry对象就会存储Entry数组中。而Entry在数组中的具体位置，会根据key的HashCode()方法计算出的哈希值来决定。如果哈希算法设计的足够好，是不会发生碰撞冲突的，但实际中肯定没有这么理想，所以在每个索引处，会有一个单向链表，来存储相同索引的Entry对象。

   然后，当调用put方法向哈希表中存储键值对时，首先计算key的hashcode，定位到合适的数组索引，然后在该索引上的单向链表进行遍历，用equals函数比较key是否存在。如果存在，则新的value值覆盖原来的value值；如果不存在，则**将新的Entry对象插入到链表头部**（1.7 1.8是在尾部插入）。插入头部也主要是为了防止尾部遍历，否则这对key的HashCode相同的Entry每次添加还要定位到尾节点。且当链表长度大于某个值（可能是8）时，链表会变为红黑树，链表的查询效率为O(n)，红黑树的查询效率为O(lgn)，可见后者的效率更高。

   最后，当需要取出一个Entry对象时，也是根据key的hashCode值来找到其存储位置，直接取出该Entry。

   key可以为null

   ```java
      static final int hash(Object key) {
       int h;
       return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
   }
   ```

3. 如何实现hashset？

   ​利用Hashmap

        * 底层实际将将该元素作为key放入HashMap。 由于HashMap的put()方法添加key-value对时，当新放入HashMap的Entry中key 与集合中原有Entry的key相同（hashCode()返回值相等，通过equals比较也返回true）， 新添加的Entry的value会将覆盖原来Entry的value，但key不会有任何改变， 因此如果向HashSet中添加一个已经存在的元素时，新添加的集合元素将不会被放入HashMap中， 原来的元素也不会有任何改变，这也就满足了Set中元素不重复的特性。 

4. volatile关键字，加1操作是否有原子性

5. AtomicInteger实现原理

   ​     通过申明一个volatile （内存锁定，同一时刻只有一个线程可以修改内存值）类型的变量，再加上unsafe.compareAndSwapInt的方法，来保证实现线程同步的。

   CAS指令在Intel CPU上称为CMPXCHG指令，**它的作用是将指定内存地址的内容与所给的某个值相比，如果相等，则将其内容替换为指令中提供的新值，如果不相等，则更新失败。**这一比较并交换的操作是原子的，不可以被中断。初一看，CAS也包含了读取、比较 (这也是种操作)和写入这三个操作，和之前的i++并没有太大区别，是的，的确在操作上没有区别，但**CAS是通过硬件命令保证了原子性**，而i++没有，且硬件级别的原子性比i++这样高级语言的软件级别的运行速度要快地多。虽然CAS也包含了多个操作，但其的运算是固定的(就是个比较)，这样的锁定性能开销很小

6. MySql两种引擎的区别（存储结构）

   都是B+树

   MyIASM引擎，B+树的数据结构中存储的内容实际上是实际数据的地址值。也就是说它的索引和实际数据是分开的，只不过使用索引指向了实际数据。这种索引的模式被称为非聚集索引。

   Innodb引擎的索引的数据结构也是B+树，只不过数据结构中存储的都是实际的数据，这种索引有被称为聚集索引。

7. 主键过长对索引效率的影响

   因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大， 如果辅助索引比较多空间浪费是可想而知的

8. 建立了a_b_c_index复合索引，那么ab bc ac 两两组合 哪个可以命中索引？

   最左原则，只有在a存在的时候才会命中索引ref，顺序无所谓，因为mysql的优化器会自动调整最佳顺序，而其他的如b bc 也会命中索引，但是命中的索引类型是index

   **index**：这种类型表示mysql会对整个该索引进行扫描。要想用到这种类型的索引，对这个索引并无特别要求，只要是索引，或者某个**联合索引的一部分**，mysql都可能会采用index类型的方式扫描。但是呢，缺点是效率不高，mysql会从索引中的第一个数据一个个的查找到最后一个数据，直到找到符合判断条件的某个索引。所以，上述语句会触发索引。
   **ref**：这种类型表示mysql会根据特定的算法快速查找到某个符合条件的索引，而不是会对索引中每一个数据都进行一一的扫描判断，也就是所谓你平常理解的使用索引查询会更快的取出数据。而要想实现这种查找，索引却是有要求的，要实现这种能快速查找的算法，索引就要满足特定的数据结构。简单说，**也就是索引字段的数据必须是有序的，才能实现这种类型的查找，才能利用到索引**

